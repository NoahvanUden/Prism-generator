import java.io.*;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.Locale;
import java.util.Scanner;

public class Model {

    String msg = "// MDP model for local spare parts stock problem\n// Generated by: Noah van Uden\n\n";

    String name = "storage";

    int machines;

    double p;
    double qD;

    int ch;
    int cem;

    String[] states = new String[] { "INIT", "SIGNAL_RECEIVED", "REPLENISHED", "FAILURE_RECEIVED" };

    double lambda;

    double[] Xs;
    double[][] Xpa;
    double[] Xu;
    double[][] XpaXu;

    Model(int m, double p, double qD, int ch, int cem, double lambda) {
        this.machines = m;

        this.p = p == 0d ? 0.01 : p;
        this.qD = qD;

        this.ch = ch;
        this.cem = cem;
        this.lambda = lambda;

        init();
    }

    Model() {
        this.machines = 50;

        this.p = 1;
        this.qD = 0.75;

        this.ch = 1;
        this.cem = 10000;
        this.lambda = 0.2;

        init();
    }

    void init() {
        double lh;

        Xs = new double[machines + 1];
        lh = (qD * lambda) / p;
        for (int i = 0; i <= machines; i++) {
            Xs[i] = poisson(lh, i);
        }
        normalize(Xs);

        Xpa = new double[machines + 1][machines + 1];
        for (int a = 0; a <= machines; a++) {
            for (int k = 0; k <= a; k++) {
                Xpa[a][k] = binomial(k,a,p);
            }
            normalize(Xpa[a]);
        }

        Xu = new double[machines + 1];
        lh = (1d - qD) * lambda;
        for (int i = 0; i <= machines; i++) {
            Xu[i] = poisson(lh, i);
        }
        normalize(Xu);

        XpaXu = new double[machines + 1][machines + 1];
        for (int a = 0; a <= machines; a++) {
            for (int k = 0; k <= machines; k++) {
                for (int i = 0; i <= k; i++) {
                    XpaXu[a][k] += Xu[i] * Xpa[a][k-i];
                }
            }
            normalize(XpaXu[a]);
        }
    }


    private double poisson(double rate, double k) {
        double lk = Math.pow(rate, k);
        double el = Math.exp(-1d * rate);
        double kfact = factorial(k);
        return (lk * el) / kfact;
    }

    private double binomial(double k, double n, double p) {
        if (k > n) return 0d;
        return choose(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
    }

    private void normalize(double[] a) {

        for (int i = 0; i < a.length; i++) {
            if (a[i] < 1E-15) {
                a[i] = 0;
            }
        }

        double sum = Arrays.stream(a).sum();
        if (sum < 1d) {
            double r = 1 / sum;
            for (int i = 0; i < a.length; i++) {
                a[i] *= r;
            }
        }
    }

    private double choose(double n, double k) {
        return factorial(n) / (factorial(k) * factorial(n - k));
    }

    private double factorial(double in) {
        if(in == 0) return 1d;
        return in * factorial(in-1);
    }

    private void softmax(double[] in) {

        double sum = 0;

        for (int i = 0; i < in.length; i++) {
            sum += Math.exp(in[i]);
        }
        for (int i = 0; i < in.length; i++) {
            in[i] = Math.exp(in[i]) / sum;
        }
    }

    private void arrayPrint(double[][] arr) {

        System.out.print("[");
        for (double[] doubles : arr) {
            arrayPrint(doubles);
        }
        System.out.print("]\n");
    }

    private void arrayPrint(double[] arr) {
        System.out.print("Sum: " + Arrays.stream(arr).sum() + " [");
        for (int j = 0; j < arr.length; j++) {
            System.out.print(arr[j]);
            if (j != arr.length-1) {
                System.out.print(", ");
            }
        }
        System.out.print("]\n");
    }

    public void toFile(String filename) {

        int enum_counter = 0;

        try (FileWriter file = new FileWriter("models/" + filename)) {

            file.write(msg);

            file.write("mdp\n\n");

//            Write enums

            for (String state : states) {
                file.write("const int " + state + " = " + enum_counter++ + ";\n");
            }

            file.write("\n");

            file.write("module " + name + "\n\n");

//            Declare variables
            file.write("\ty: [-" + machines + ".." + machines + "] init 0;\n");
            file.write("\ta: [0" + ".." + machines + "] init 0;\n");
            file.write("\ts: [" + states[0] + ".." + states[states.length-1] + "] init " + states[0] + ";\n");
            file.write("\n");

//            Declare transitions

//            INIT
            file.write("\t[] s=INIT -> ");
            for (int i = 0; i <= machines; i++) {
                if (Xs[i] != 0d) {
                    if (i != 0) {
                        file.write(" + ");
                    }
                    file.write(Xs[i] + ":(a'=" + i + ")&(s'=" + states[1] + ")");
                }
            }
            file.write(";\n\n");

//            SIGNAL_RECEIVED
            for (int i = 0; i <= machines; i++) {
                file.write("\t[] s=" + states[1] + " -> (y'=" + i + ")&(s'=" + states[2] + ");\n");
                if (i == machines) {
                    file.write("\n");
                }
            }

//            REPLENISHED
            for (int a = 0; a <= machines; a++) {
                for (int y = 0; y <= machines; y++) {
                    file.write("\t[] s=" + states[2] + " & a=" + a + " & y=" + y + " -> ");
                    for (int k = 0; k <= machines; k++) {
                        if (XpaXu[a][k] != 0d) {
                            file.write( XpaXu[a][k] + ":(y'=" + (y - k) + ")&(s'=" + states[3] + ")");
                            if (k != machines && XpaXu[a][k+1] != 0d) {
                                file.write(" + ");
                            }
                        }
                    }
                    file.write(";\n");
                }
            }

            file.write("\n");

//            FAILURE_RECEIVED
            file.write("\t[] s=" + states[3] + " & y<" + 0 + " -> ");
            for (int j = 0; j <= machines; j++) {
                if (Xs[j] != 0d) {
                    file.write(Xs[j] + ":(y'=0)&(a'=" + j + ")&(s'=" + states[1] + ")");
                    if (j != machines && Xs[j+1] != 0d) {
                        file.write(" + ");
                    }
                }
            }
            file.write(";\n");

            file.write("\t[] s=" + states[3] + " & y>=" + 0 + " -> ");
            for (int j = 0; j <= machines; j++) {
                if (Xs[j] != 0d) {
                    if (j != 0) {
                        file.write(" + ");
                    }
                    file.write(Xs[j] + ":(a'=" + j + ")&(s'=" + states[1] + ")");
                }
            }
            file.write(";\n");


            file.write("\n");
            file.write("endmodule\n\n");

//            Declare emergency rewards
//            file.write("rewards \"emergency\"\n\n");
            file.write("rewards \n\n");

            for (int y = -machines; y < 0; y++) {
                file.write("\ts=" + states[3] + " & y=" + y + " : " + -y * cem + ";\n");
            }

//            file.write("\n");
//            file.write("endrewards\n\n");

//            Declare holding rewards
//            file.write("rewards \"holding\"\n\n");

            for (int y = 1; y <= machines; y++) {
                file.write("\ts=" + states[3] + " & y=" + y + " : " + y * ch + ";\n");
            }

            file.write("\n");
            file.write("endrewards");

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    double getResult(String file, int periods) {
        ProcessBuilder processBuilder = new ProcessBuilder();

        int runs = (periods * 3) + 1;

        String command = "prism -dir .\\models " + file + " -pctl \"Rmin=? [ C<=" + runs + " ]\" -exportresults result.txt";

        processBuilder.command("cmd.exe", "/c", command);

        try {
            Process process = processBuilder.start();

            StringBuilder output = new StringBuilder();

            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()));

            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line + "\n");
            }

            int exitVal = process.waitFor();
            if (exitVal != 0) {
                System.out.print(output);
                throw new RuntimeException("Error: " + exitVal);
            }

        } catch (IOException | InterruptedException e) {
            throw new RuntimeException(e);
        }

        double result = -1d;

        try {
            Scanner scanner = new Scanner(new File("models/result.txt"));

            scanner.nextLine();
            result = Double.parseDouble(scanner.next());

            result = result / periods;

        } catch (FileNotFoundException e) {
            throw new RuntimeException(e);
        }

        return result;
    }

    public static void main(String[] args) {

//        Ensures doubles are printed with a decimal dot
        Locale.setDefault(Locale.ENGLISH);

        double[] ps = new double[] {
                0.5,
                0.75
        };

        for (double p : ps) {
            Model model = new Model(
                    50,
                    p,
                    0.5,
                    1,
                    10000,
                    0.2
            );

            String filename = "model.nm";

            model.toFile(filename);

            System.out.format("%.2f;%.2f\n", p, model.getResult(filename, 20));
        }


    }

}
